{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this unit, we describe the procedure for training the commuter activity classifier. Further, we present the classification result for commuter activity classifier."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Commuter activity classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Import and initialize MongoClient'''\n",
    "import subprocess\n",
    "import os\n",
    "import sys\n",
    "import json\n",
    "from pymongo import     MongoClient\n",
    "con = MongoClient()\n",
    "from scipy import integrate\n",
    "import numpy as np\n",
    "import pprint\n",
    "import math\n",
    "from pathlib import Path"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Import project specific library'''\n",
    "sys.path.append(os.path.join(os.getcwd(), 'LibCode'))\n",
    "import ReadAcclGPSRecord\n",
    "import SegmentsOtherThanStoppageSegments\n",
    "import EarthaxisAcceleration\n",
    "import EarthaxisAccelerationOnRawRecords\n",
    "import ComputeFeaturesTransportMode\n",
    "import FeaturesExtraction\n",
    "import TransportModeFeatureHelper\n",
    "import CAC_Helper"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Import Libs'''\n",
    "from sklearn.model_selection import StratifiedKFold\n",
    "from sklearn.metrics import accuracy_score, confusion_matrix,precision_score, recall_score, f1_score\n",
    "from sklearn import tree\n",
    "from sklearn.svm import SVC\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.naive_bayes import GaussianNB\n",
    "from collections import Counter\n",
    "from sklearn.impute import SimpleImputer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<module 'CAC_Helper' from '/home/pruthvish/JRF/GitVersion_APTS_Software_Np/code/LibCode/CAC_Helper.py'>"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'''For updating the lib changes effects'''\n",
    "import importlib\n",
    "importlib.reload(ReadAcclGPSRecord)\n",
    "importlib.reload(SegmentsOtherThanStoppageSegments)\n",
    "importlib.reload(EarthaxisAcceleration)\n",
    "importlib.reload(EarthaxisAccelerationOnRawRecords)\n",
    "importlib.reload(ComputeFeaturesTransportMode)\n",
    "importlib.reload(FeaturesExtraction)\n",
    "importlib.reload(TransportModeFeatureHelper)\n",
    "importlib.reload(CAC_Helper)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Save in MongoDB\n",
    "The commuter activity classifier is trained and validated using the trip records of the learning module. Aforementioned, the learning module application is carried by the data colleciton volunteers on their trips on different types of vehicles. The accelerometer record is stored in the `RouteName = HAR_PDPU_SANAND` database of MongoDB. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ReadAndSaveData(SitStandRecordDir, RouteName):\n",
    "    \n",
    "    '''\n",
    "    input: The route name and dataset directory name\n",
    "    \n",
    "    output: None\n",
    "    \n",
    "    function: It fetches the data records placed in the specified data set directory \n",
    "    and save them in the MongoDB database\n",
    "    '''    \n",
    "    \n",
    "    '''E.g., BM, CM, Bike, Car'''\n",
    "    for fileName in [f for f in os.listdir(os.path.join(SitStandRecordDir,RouteName))]:\n",
    "        fileNameList = fileName.split('_')\n",
    "        #print(fileName)\n",
    "        ReadAcclGPSRecord.SaveInMongoFunction(RouteName,\n",
    "                                              os.path.join(SitStandRecordDir,RouteName,fileName),\n",
    "                                              fileNameList[0]+'.'+fileNameList[1]+'.'+fileNameList[2]+'.'+fileNameList[3])\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Decomposition of accelerometer data\n",
    "The accelerometer record data is decomposed to `horizontal and vertical components` with the `IntervalLength` of `140 points.`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ComputeEarthAxisComponentRaw(RouteName, IntervalLength, RecordType):\n",
    "    \n",
    "    '''\n",
    "    input: The route name, interval length for computing accelerometer components\n",
    "    and record type variable to specify the segment type of the records.\n",
    "    \n",
    "    output: None\n",
    "    \n",
    "    function: It extracts the raw accelerometer records from the MongoDB database\n",
    "    for the entire trip records and executes the code to compute the horizontal and\n",
    "    vertical components based on the method proposed in Jigsaw paper. \n",
    "    '''    \n",
    "    \n",
    "    '''To EarthAxis'''\n",
    "    SingleTripsInfo = [LR['SingleTripInfo'] for LR in \n",
    "                       con[RouteName]['TripsInfo'].find({'ConvertedToEarthAxis':False})]\n",
    "\n",
    "    for SingleTripInfo in SingleTripsInfo:\n",
    "        print(SingleTripInfo)\n",
    "\n",
    "        AcclMagRecord = [collection for collection in \n",
    "                         con[RouteName][SingleTripInfo+'.AcclMagData.Raw'].find().sort([('GPSIndex',1)])]\n",
    "\n",
    "        AcclMagRecord = CAC_Helper.GetSlicedAcclMagRecord(RouteName,SingleTripInfo)\n",
    "\n",
    "        EarthaxisAccelerationOnRawRecords.ProcessEarthaxisHVComponentUsingJigSawMethod (RouteName,\n",
    "                                                                                        SingleTripInfo,\n",
    "                                                                                        AcclMagRecord,\n",
    "                                                                                        IntervalLength,RecordType)\n",
    "        con[RouteName]['TripsInfo'].update_one(\n",
    "            {'SingleTripInfo':SingleTripInfo},{'$set':{'ConvertedToEarthAxisRaw':True}})\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Feature extraction\n",
    "The feature `set-1 to set-4` are computed using the orientation independent horizontal and vertical components of accelerometer records for the window of `128 samples and 50% overlap`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "def GetMode(SingleTripInfo):\n",
    "\n",
    "    '''\n",
    "    input: The trip name\n",
    "    output: The mode of the trip name\n",
    "    function: It extracts the mode (label) of the trip records\n",
    "    '''\n",
    "    \n",
    "    if (SingleTripInfo.split('.')[1] == 'Seating' or SingleTripInfo.split('.')[1] == 'Sitting') and (SingleTripInfo.split('.')[2]=='Hand'):\n",
    "        Mode = 0\n",
    "        \n",
    "    elif (SingleTripInfo.split('.')[1] == 'Seating' or SingleTripInfo.split('.')[1] == 'Sitting') and (SingleTripInfo.split('.')[2]=='ShirtPocket'):\n",
    "        Mode = 1\n",
    "        \n",
    "    elif (SingleTripInfo.split('.')[1] == 'Standing') and (SingleTripInfo.split('.')[2]=='ShirtPocket'):\n",
    "        Mode = 2\n",
    "\n",
    "    elif (SingleTripInfo.split('.')[1] == 'Standing') and (SingleTripInfo.split('.')[2]=='TrouserPocket'):\n",
    "        Mode = 3\n",
    "                \n",
    "    elif (SingleTripInfo.split('.')[1] == 'Standing') and (SingleTripInfo.split('.')[2]=='Hand'):\n",
    "        Mode = 4\n",
    "        \n",
    "    return(Mode)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ComputeFeatures_Raw(ProjectDataUsed, WindowList, WindowIndex, RecordType, RouteName):\n",
    "    \n",
    "    '''\n",
    "    input: The ProjectDataUsed variable specify whether the project dataset should to use project \n",
    "    dataset or the user collected dataset. The other variables specify the window size for feature\n",
    "    computation, record type (Raw or Segment other than stoppage segment), and route name.\n",
    "    \n",
    "    output: None\n",
    "    \n",
    "    function: It extracts the appropriate accelerometer components from the MongoDB database based\n",
    "    on the provided input and computes the features on the windowed accelerometer component. The \n",
    "    computed features are stored in the MongoDB database.\n",
    "    '''\n",
    "    \n",
    "    SingleTripsInfo = [LR['SingleTripInfo'] for LR in \n",
    "                       con[RouteName]['TripsInfo'].find({'FeaturesExtracted':False})]\n",
    "    for SingleTripInfo in SingleTripsInfo:\n",
    "        print(SingleTripInfo)\n",
    "        HVRecord = [Rec for Rec in \n",
    "                    con[RouteName][SingleTripInfo+'.EAccHVComponent'+RecordType].find().sort([('GPSIndex',1)])]\n",
    "\n",
    "        #print(HVRecord[0])\n",
    "        #input()\n",
    "        Mode = GetMode(SingleTripInfo)\n",
    "\n",
    "        FeaturesExtraction.ComputeFeatureForComponents(RouteName,HVRecord,Mode,\n",
    "                                                       WindowSize,SingleTripInfo,RecordType)\n",
    "\n",
    "        ComputeFeaturesTransportMode.ComputeFeature(SingleTripInfo,HVRecord,Mode,WindowSize,\n",
    "                                                    RecordType, RouteName)\n",
    "\n",
    "        con[RouteName]['TripsInfo'].update_one({'SingleTripInfo':SingleTripInfo},\n",
    "                                               {'$set':{'FeaturesExtracted':True}})\n",
    "\n",
    "        \n",
    "    '''\n",
    "    if ProjectDataUsed==True:\n",
    "    \n",
    "\n",
    "    else:\n",
    "        Trips = SingleTripsInfo = [LR['SingleTripInfo'] for LR in con[RouteName]['TripsInfo'].find(\n",
    "            {'ConvertedToEarthAxisRaw':True})]\n",
    "\n",
    "        BusTrips = [Trip for Trip in Trips if Trip.split['_'][1]=='Bus']\n",
    "        CarTrips = [Trip for Trip in Trips if Trip.split['_'][1]=='Car']\n",
    "        BikeTrips = [Trip for Trip in Trips if Trip.split['_'][1]=='Bike']\n",
    "\n",
    "        TransportModeFeatureHelper.GetFeaturesForGivenTripType (BusTrips, 0,\n",
    "                                                                WindowList[WindowIndex],RecordType, RouteName)\n",
    "        TransportModeFeatureHelper.GetFeaturesForGivenTripType (CarTrips, 1,\n",
    "                                                                WindowList[WindowIndex],RecordType, RouteName)\n",
    "        TransportModeFeatureHelper.GetFeaturesForGivenTripType (BikeTrips, 2,\n",
    "                                                                WindowList[WindowIndex],RecordType, RouteName)\n",
    "    '''        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Processing: For Records other than Stoppage Segment\n",
    "This section describes the procedure for training the classifier on the `segments other than stoppage segment`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Decomposition of accelerometer data\n",
    "The accelerometer record data is decomposed to `horizontal and vertical components` with the `IntervalLength` of `140 points.`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ExtractSegment_EarthAxis_OtherThanStoppages(RouteName, Speed_H = 5.6, Speed_L = 3):\n",
    "    \n",
    "    '''\n",
    "    input: The route name, interval length for computing accelerometer components, \n",
    "    speed range for computing stoppage segments and record type variable to specify\n",
    "    the segment type of the records.\n",
    "    \n",
    "    output: None\n",
    "    \n",
    "    function: It extracts the raw accelerometer records from the MongoDB database\n",
    "    for the computing stoppage segments and executes the code to compute the horizontal \n",
    "    and vertical components based on the method proposed in Jigsaw paper. \n",
    "    '''\n",
    "        \n",
    "    \n",
    "    '''Extract segment other than stoppage segments'''\n",
    "    if ProjectDataUsed==True:\n",
    "        BMSingleTripsInfoList,CMSingleTripsInfoList,PDSingleTripsInfoList = SegmentsOtherThanStoppageSegments.GetTripsBasedOnType(RouteName)\n",
    "\n",
    "        SegmentsOtherThanStoppageSegments.GetBMAndPDSegments(RouteName,BMSingleTripsInfoList,Speed_H, Speed_L)\n",
    "        SegmentsOtherThanStoppageSegments.GetBMAndPDSegments(RouteName,PDSingleTripsInfoList,Speed_H, Speed_L)\n",
    "        SegmentsOtherThanStoppageSegments.GetCMSegments(RouteName,CMSingleTripsInfoList,BMSingleTripsInfoList)\n",
    "        SegmentsOtherThanStoppageSegments.GetGPSAndAcclReadOfSegment(RouteName)\n",
    "\n",
    "    else:\n",
    "        SingleTripsInfo = [LR['SingleTripInfo'] for LR in con[RouteName]['TripsInfo'].find({'SegmentExtracted':False})]\n",
    "        SegmentsOtherThanStoppageSegments.GetBMAndPDSegments(RouteName,SingleTripsInfo, Speed_H, Speed_L)\n",
    "        SegmentsOtherThanStoppageSegments.GetGPSAndAcclReadOfSegment(RouteName)\n",
    "\n",
    "    '''\n",
    "    for SingleTripInfo in SingleTripsInfo:\n",
    "        con[RouteName]['TripsInfo'].update_one(\n",
    "            {'SingleTripInfo':SingleTripInfo},{'$set':{'ConvertedToEarthAxis':False}})\n",
    "    '''\n",
    "    \n",
    "    EarthaxisAcceleration.ConvertToEarthaxisAcc(RouteName,RecordType)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ComputeFeatures_SegmentOtherThanStoppages_SitStand(ProjectDataUsed, WindowList, \n",
    "                                                       WindowIndex, RecordType, RouteName):\n",
    "    \n",
    "    '''\n",
    "    input: \n",
    "        ProjectDataUsed: flag to determine whether the project dataset or user dataset is used\n",
    "        WindowList and WindowIndex: The window length for feature computation\n",
    "        RecordType: The flag to determine whether the features of entire trip is used (.Raw) or\n",
    "        the features of segment other than stoppage segments is used (.SegmentOtherThanStoppage).\n",
    "        \n",
    "    output: None\n",
    "    \n",
    "    function: It computes the features for the segment other than stoppage segments for the \n",
    "    provided route name.\n",
    "    '''\n",
    "    \n",
    "    '''Recent Attempt'''\n",
    "    Trips = [LR['SingleTripInfo'] for LR in con[RouteName]['TripsInfo'].find(\n",
    "        {'ConvertedToEarthAxis':True})]\n",
    "\n",
    "    #Mode = GetMode(Trips)\n",
    "    \n",
    "    TransportModeFeatureHelper.ExtractFeaturesOfGivenTypeOfTrip(Trips,\"Bus\",0,\n",
    "                                                                WindowList[WindowIndex],RecordType, RouteName)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## For saving Mongo data in numpy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "def LoadInMongoFromNp(RouteName, NpPathDir):\n",
    "    \n",
    "    '''\n",
    "    input: The route name and numpy directory path\n",
    "    output: The MongoDB database collections from the Numpy files\n",
    "    function: It creates the MongoDB database of TripsInfo collections \n",
    "    and features collections from the Numpy files.\n",
    "    '''    \n",
    "    \n",
    "    CollectionName = 'TripsInfo'\n",
    "    TripsInfoRecords = np.load(f'{NpPathDir}/{RouteName}/{CollectionName}.npy', allow_pickle=True)\n",
    "    \n",
    "    print('Saving data in mongoDB')\n",
    "    print(RouteName, CollectionName)\n",
    "    con[RouteName][CollectionName].insert_many(TripsInfoRecords.tolist())\n",
    "    \n",
    "    CollectionNames = os.listdir(f'{NpPathDir}/{RouteName}')\n",
    "    #print(CollectionNames)\n",
    "    \n",
    "    CollectionNames_1 = [rec for rec in CollectionNames if '\\'.' not in rec] # To address the error\n",
    "    CollectionNames_2 = [rec for rec in CollectionNames if 'Feature' in rec]\n",
    "    \n",
    "    #print('Saving data in mongoDB')\n",
    "    for Collection in CollectionNames_2:\n",
    "        RecordsList = np.load(f'{NpPathDir}/{RouteName}/{Collection}', allow_pickle=True)\n",
    "        #print(Collection)\n",
    "        #pprint.pprint(RecordsList[0:3])\n",
    "        \n",
    "        CollectionName = Collection[0:-4]\n",
    "        \n",
    "        print(RouteName, CollectionName)\n",
    "        con[RouteName][CollectionName].insert_many(RecordsList.tolist())\n",
    "        \n",
    "    \n",
    "    \n",
    "def SaveInNp(RouteName, NpPathDir):\n",
    "    \n",
    "    '''\n",
    "    input: The route name and numpy directory path\n",
    "    output: Numpy files of the MongoDB database\n",
    "    function: It stores the Numpy files for the MongoDB database in the specified directory path\n",
    "    '''\n",
    "        \n",
    "    \n",
    "    CollectionNames = [Collection for Collection in \n",
    "                        con[RouteName].list_collection_names() if Collection!='system.indexes']\n",
    "\n",
    "    for CollectionName in CollectionNames:\n",
    "        print('CollectionName', CollectionName)\n",
    "        RecordsList = [rec for rec in con[RouteName][CollectionName].find().sort([('_id',1)])]\n",
    "\n",
    "        for RecordDict in RecordsList:\n",
    "            del[RecordDict['_id']]\n",
    "\n",
    "        if os.path.exists(os.path.join(NpPathDir, RouteName)) == False:\n",
    "            os.mkdir(os.path.join(NpPathDir, RouteName))\n",
    "\n",
    "            \n",
    "        #np.save(f'{Path}/{Database}/{CollectionName}.npy', RecordsList)\n",
    "        np.save(os.path.join(NpPathDir, RouteName,f'{CollectionName}.npy'), RecordsList)\n",
    "        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Execute the preprocessing"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "path = Path(os.getcwd())\n",
    "OneLevelUpPath = path.parents[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "IntervalLength = 160\n",
    "\n",
    "'''Trips and Window size for Feature extraction'''\n",
    "#BMSingleTripsInfoList,CMSingleTripsInfoList,PDSingleTripsInfoList = TransportModeFeatureHelper.GetTripsBasedOnType(RouteName)\n",
    "WindowList = [32,64,128,256,512]\n",
    "WindowIndex = 2\n",
    "WindowSize = WindowList[WindowIndex]\n",
    "\n",
    "'''For segment other than stoppages'''\n",
    "Speed_H = 5.6\n",
    "Speed_L = 3\n",
    "\n",
    "'''Path for Np'''\n",
    "NpPathDir = os.path.join(str(OneLevelUpPath), 'data','NpData')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Variables\n",
    "\n",
    "`ProjectDataUsed`: determines whether the project data or the user's own data is used for execution.\n",
    "\n",
    "`UsedPreTrained`: determines whether the pretrained and precomputed dataset or raw data is used for execution.\n",
    "\n",
    "`UseMongoDB`: determines whether the MonngoDB database or Numpy file is used for execution.\n",
    "\n",
    "`ReducedKFolds`: If false: one fold is used, else ten-fold is used"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''\n",
    "ProjectDataUsed = True\n",
    "UsedPreTrained = True\n",
    "ReducedKFolds = False\n",
    "UseMongoDB = True\n",
    "'''\n",
    "\n",
    "#'''\n",
    "ProjectDataUsed = True\n",
    "UsedPreTrained = True\n",
    "ReducedKFolds = True\n",
    "UseMongoDB = False\n",
    "#'''\n",
    "\n",
    "'''\n",
    "ProjectDataUsed = True\n",
    "UsedPreTrained = False\n",
    "ReducedKFolds = False\n",
    "UseMongoDB = False\n",
    "'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#SitStandRecordDir = '/home/pruthvish/JRF/GitVersion_PMC/Data/SitStandRecord'\n",
    "if ProjectDataUsed==True:\n",
    "    SitStandRecordDir = os.path.join(str(OneLevelUpPath), 'data','SitStandRecord','')\n",
    "else:\n",
    "    SitStandRecordDir = os.path.join(str(OneLevelUpPath), 'data','UserData','SitStandRecord','')\n",
    "#RouteNamesList = [f for f in os.listdir(SitStandRecordDir)]\n",
    "RouteNamesList = ['HAR_PDPU_SANAND_ ', 'HAR_PDPU_SANAND_Triggers_']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Code"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "HAR_PDPU_SANAND_Triggers_\n",
      "HAR_PDPU_SANAND_\n"
     ]
    }
   ],
   "source": [
    "for RouteName in RouteNamesList:\n",
    "    print(RouteName)\n",
    "    if UsedPreTrained==False and UseMongoDB==True:\n",
    "        print('Reading data and saving in MongoDB')\n",
    "        ReadAndSaveData(SitStandRecordDir, RouteName)\n",
    "        \n",
    "        RecordType = '.Raw'\n",
    "        print(f'Computing preprocessing for {RecordType} segments')\n",
    "        ComputeEarthAxisComponentRaw(RouteName, IntervalLength, RecordType)\n",
    "        print(f'Computing features for {RecordType} segments')\n",
    "        ComputeFeatures_Raw(ProjectDataUsed, WindowList, WindowIndex, RecordType, RouteName)\n",
    "        \n",
    "        if RouteName == 'HAR_PDPU_SANAND_':\n",
    "            RecordType = '.SegmentOtherThanStoppage'\n",
    "            print(f'Computing preprocessing for {RecordType} segments')\n",
    "            ExtractSegment_EarthAxis_OtherThanStoppages(RouteName, Speed_H , Speed_L)\n",
    "            print(f'Computing features for {RecordType} segments')\n",
    "            ComputeFeatures_SegmentOtherThanStoppages_SitStand(ProjectDataUsed, WindowList, WindowIndex, \n",
    "                                                      RecordType, RouteName)\n",
    "        \n",
    "        print('Saving MongoData in Np files')\n",
    "        SaveInNp(RouteName, NpPathDir)\n",
    "    \n",
    "    elif UseMongoDB==True:\n",
    "        RouteNamesListInDB = con.list_database_names()\n",
    "        if RouteName not in RouteNamesListInDB:\n",
    "            '''Load the data for RouteName, if RouteName is not in RouteNamesList'''\n",
    "            print('Loading MongoData from Np files')\n",
    "            LoadInMongoFromNp(RouteName, NpPathDir)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Import Libs'''\n",
    "from sklearn.model_selection import StratifiedKFold\n",
    "from sklearn.metrics import accuracy_score, confusion_matrix,precision_score, recall_score, f1_score\n",
    "from sklearn import tree\n",
    "from sklearn.svm import SVC\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.naive_bayes import GaussianNB\n",
    "from collections import Counter\n",
    "from sklearn.impute import SimpleImputer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Variables for Classification'''\n",
    "ResultPathDir = os.path.join(str(OneLevelUpPath), 'results','SitStand','')\n",
    "\n",
    "if os.path.exists(ResultPathDir) == False:\n",
    "    os.mkdir(ResultPathDir)\n",
    "\n",
    "TrainedModelPathDir = os.path.join(str(OneLevelUpPath), 'data', 'TrainedModel','SitStand','')\n",
    "'''Any one route type as decided by Stoppage experiment'''\n",
    "#RecordType = '.SegmentOtherThanStoppage'\n",
    "#RecordType = '.StoppageSegment'\n",
    "RecordType = '.Raw'\n",
    "\n",
    "ClassifierList = [GaussianNB(), LogisticRegression(random_state=0), \n",
    "                  RandomForestClassifier(max_depth=20), tree.DecisionTreeClassifier(), \n",
    "                  SVC(gamma='auto')\n",
    "                 ]\n",
    "ClassifierNameList = ['NB', 'LogisticRegression', 'RF', 'DT', 'SVC']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "def GetFeaturesForClass(RouteNameTestList, FeatureType, RecordType,\n",
    "                        SelectedFeatures, SelectedFeaturesFlag, NpPathDir, UseMongoDB):\n",
    "    '''\n",
    "    if ProjectDataUsed==True:\n",
    "        X, y = TMC_Helper.GetData(FeatureType, RecordType, SelectedFeatures, SelectedFeaturesFlag)\n",
    "    else:\n",
    "    '''\n",
    "    #X = []\n",
    "    #y = []\n",
    "    if UseMongoDB==True:\n",
    "        First_InputFlag = True\n",
    "\n",
    "        for RouteNameTest in RouteNameTestList:\n",
    "            X_Route, y_Route = CAC_Helper.GetData_User(RouteNameTest, FeatureType, RecordType,\n",
    "                                                       SelectedFeatures, SelectedFeaturesFlag)\n",
    "\n",
    "            if First_InputFlag==True:\n",
    "                X = X_Route\n",
    "                y = y_Route\n",
    "                First_InputFlag = False\n",
    "\n",
    "            else:\n",
    "                X = np.concatenate((X, X_Route))\n",
    "                y = np.concatenate((y, y_Route))\n",
    "                '''\n",
    "                X += X_Route\n",
    "                y += y_Route\n",
    "                '''\n",
    "\n",
    "            print('X.shape', X.shape)\n",
    "            print('y.shape', y.shape)\n",
    "        \n",
    "        '''Save in NpData'''\n",
    "        \n",
    "        if os.path.exists(os.path.join(NpPathDir,'SitStand'))==False:\n",
    "            os.mkdir(os.path.join(NpPathDir,'SitStand'))\n",
    "            \n",
    "        np.save(f'{NpPathDir}/SitStand/X_{FeatureType}_{RecordType}_{SelectedFeaturesFlag}.npy', X)\n",
    "        np.save(f'{NpPathDir}/SitStand/y_{FeatureType}_{RecordType}_{SelectedFeaturesFlag}.npy', y)\n",
    "        \n",
    "    else:\n",
    "        X = np.load(f'{NpPathDir}/SitStand/X_{FeatureType}_{RecordType}_{SelectedFeaturesFlag}.npy',\n",
    "                    allow_pickle=True)\n",
    "        y = np.load(f'{NpPathDir}/SitStand/y_{FeatureType}_{RecordType}_{SelectedFeaturesFlag}.npy',\n",
    "                    allow_pickle=True)\n",
    "    \n",
    "    return(X, y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ApplyClassification(Classes, FeatureType, RecordType, SelectedFeatures, SelectedFeaturesFlag,\n",
    "                        Classifier, ClassifierName, ResultPathDir, ProjectDataUsed, RouteNameTestList, \n",
    "                        UsedPreTrained, ClassifierName_ForModelSave, TrainedModelPathDir, ReducedKFolds, \n",
    "                        NpPathDir, UseMongoDB\n",
    "                       ):\n",
    "    \n",
    "    '''\n",
    "    input: \n",
    "        Classes: The number of classes\n",
    "        \n",
    "        FeatureType and RecordType: feature type and record type information\n",
    "        \n",
    "        SelectedFeatures and SelectedFeaturesFlag: selected features list and flag to \n",
    "        determine if selected features are list is used\n",
    "        \n",
    "        Classifier and ClassifierName: classifier object variable and classifier name\n",
    "        \n",
    "        ResultPathDir: path of result directory\n",
    "        \n",
    "        ProjectDataUsed: flag to determine whether the project dataset or user dataset is used\n",
    "        \n",
    "        RouteNameTestList: The route names list to be considered during classification\n",
    "        \n",
    "        UsedPreTrained: Flag to determine whether the pretrained classifier should be used\n",
    "        or the classifier is to be trained\n",
    "        \n",
    "        ClassifierName_ForModelSave: the name of classifier for saving a model\n",
    "        \n",
    "        TrainedModelPathDir: path of trainedModel directory \n",
    "        \n",
    "        NpPathDir: \n",
    "        \n",
    "        UseMongoDB: \n",
    "    \n",
    "    output: None\n",
    "    \n",
    "    function: It trains and validates the classifier the ten-fold cross-validation with stratified\n",
    "    sampling of each class. The performance metrics of the classifier is stores as a txt file in the\n",
    "    result directory\n",
    "    \n",
    "    '''    \n",
    "    \n",
    "    MetricsDict = CAC_Helper.InitializeMetricsDict(Classes)\n",
    "    \n",
    "    \n",
    "    X, y = GetFeaturesForClass(RouteNameTestList, FeatureType, RecordType,\n",
    "                               SelectedFeatures, SelectedFeaturesFlag, NpPathDir, UseMongoDB)    \n",
    "    \n",
    "    \n",
    "    MetricsDict = CAC_Helper.TrainAndPredict(X, y, Classifier, MetricsDict, ResultPathDir,\n",
    "                                             ClassifierName, UsedPreTrained, \n",
    "                                             ClassifierName_ForModelSave, TrainedModelPathDir, ReducedKFolds)\n",
    "    CAC_Helper.PrintMetricsDict(ClassifierName, ResultPathDir, FeatureType, RecordType,\n",
    "                                SelectedFeaturesFlag, MetricsDict)\n",
    "    \n",
    "    CAC_Helper.InfereSitStand_And_PrintMetrics(MetricsDict, ClassifierName, ResultPathDir)\n",
    "    \n",
    "    '''\n",
    "    filename = 'finalized_model.sav'\n",
    "    pickle.dump(model, open(ResultPathDir, 'wb'))\n",
    "    '''\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "Classes = 5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Classifier, ClassifierName GaussianNB() NB\n",
      "Feature set-1\n",
      "Feature set-2\n",
      "Feature set-3\n",
      "Feature set-4\n",
      "Classifier, ClassifierName LogisticRegression(random_state=0) LogisticRegression\n",
      "Feature set-1\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Feature set-2\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Feature set-3\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Feature set-4\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "/home/pruthvish/JRF/RoadNetwork/RoadNetwork_VirtualEnv/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Classifier, ClassifierName RandomForestClassifier(max_depth=20) RF\n",
      "Feature set-1\n",
      "Feature set-2\n",
      "Feature set-3\n",
      "Feature set-4\n",
      "Classifier, ClassifierName DecisionTreeClassifier() DT\n",
      "Feature set-1\n",
      "Feature set-2\n",
      "Feature set-3\n",
      "Feature set-4\n",
      "Classifier, ClassifierName SVC(gamma='auto') SVC\n",
      "Feature set-1\n",
      "Feature set-2\n",
      "Feature set-3\n",
      "Feature set-4\n"
     ]
    }
   ],
   "source": [
    "for Classifier, ClassifierName in zip(ClassifierList, ClassifierNameList):\n",
    "    print('Classifier, ClassifierName', Classifier, ClassifierName)\n",
    "    #for RecordType in ['.Raw', '.SegmentOtherThanStoppage']:\n",
    "\n",
    "    '''Feature set-1'''\n",
    "    FeatureType = '.HARFeature'\n",
    "    SelectedFeaturesFlag = False\n",
    "    SelectedFeatures = []\n",
    "\n",
    "    print('Feature set-1')\n",
    "    ClassifierName_ForModelSave = ClassifierName+\"_Set1\"\n",
    "    ApplyClassification(Classes, FeatureType, RecordType, SelectedFeatures, SelectedFeaturesFlag,\n",
    "                        Classifier, ClassifierName, ResultPathDir, ProjectDataUsed, RouteNamesList,\n",
    "                        UsedPreTrained, ClassifierName_ForModelSave, TrainedModelPathDir, ReducedKFolds, \n",
    "                        NpPathDir, UseMongoDB\n",
    "                       )\n",
    "\n",
    "    '''Feature set-2'''\n",
    "    FeatureType = '.HARFeature'\n",
    "    SelectedFeaturesFlag = True\n",
    "    ClassifierName_ForModelSave = ClassifierName+\"_Set2\"\n",
    "    SelectedFeatures = CAC_Helper.SelectedFeaturesForFeatureType(FeatureType)\n",
    "\n",
    "    print('Feature set-2')\n",
    "\n",
    "    ApplyClassification(Classes, FeatureType, RecordType, SelectedFeatures, SelectedFeaturesFlag,\n",
    "                        Classifier, ClassifierName, ResultPathDir, ProjectDataUsed, RouteNamesList, \n",
    "                        UsedPreTrained, ClassifierName_ForModelSave, TrainedModelPathDir, ReducedKFolds, \n",
    "                        NpPathDir, UseMongoDB\n",
    "                       )\n",
    "\n",
    "    '''Feature set-3'''\n",
    "    FeatureType = '.TransportFeatures'\n",
    "    SelectedFeatures = []\n",
    "    SelectedFeaturesFlag = False\n",
    "    print('Feature set-3')\n",
    "    ClassifierName_ForModelSave = ClassifierName+\"_Set3\"\n",
    "\n",
    "    ApplyClassification(Classes, FeatureType, RecordType, SelectedFeatures, SelectedFeaturesFlag,\n",
    "                        Classifier, ClassifierName, ResultPathDir, ProjectDataUsed, RouteNamesList,\n",
    "                        UsedPreTrained, ClassifierName_ForModelSave, TrainedModelPathDir, ReducedKFolds,\n",
    "                        NpPathDir, UseMongoDB\n",
    "                       )   \n",
    "\n",
    "\n",
    "    '''Feature set-4'''\n",
    "    FeatureType = '.TransportFeatures'\n",
    "    SelectedFeatures = CAC_Helper.SelectedFeaturesForFeatureType(FeatureType)\n",
    "    SelectedFeaturesFlag = True\n",
    "\n",
    "    print('Feature set-4')\n",
    "    ClassifierName_ForModelSave = ClassifierName+\"_Set4\"\n",
    "    ApplyClassification(Classes, FeatureType, RecordType, SelectedFeatures, SelectedFeaturesFlag,\n",
    "                        Classifier, ClassifierName, ResultPathDir, ProjectDataUsed, RouteNamesList,\n",
    "                        UsedPreTrained, ClassifierName_ForModelSave, TrainedModelPathDir, ReducedKFolds, \n",
    "                        NpPathDir, UseMongoDB\n",
    "                       )        \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Results for .Raw, .HARFeature, and selected features flag: False\n",
      "ConfusionMatrix \n",
      "[[845.   0.   4.  24.   5.]\n",
      " [ 12. 902.   0.   5.   3.]\n",
      " [  1.   0. 859.   5.   1.]\n",
      " [111.   0.  26. 714.   1.]\n",
      " [ 78.   5.   6.  23. 309.]]\n",
      " \n",
      "PrecissionValue \n",
      "[0.80706781 0.99448732 0.95977654 0.92607004 0.96865204]\n",
      " \n",
      "RecallValue \n",
      "[0.96241458 0.97830803 0.99191686 0.83802817 0.73396675]\n",
      " \n",
      "F1ScoreValue \n",
      "[0.87792208 0.98633133 0.97558206 0.87985213 0.83513514]\n",
      " \n",
      "AccuracyValue \n",
      "0.9212998222899214\n",
      " \n",
      "Inference for sit-stand \n",
      "SitStand_ConfusionMetrics \n",
      "[[1759.   41.]\n",
      " [ 195. 1944.]]\n",
      " \n",
      "PrecissionMetrics \n",
      "[0.90020471 0.97934509]\n",
      " \n",
      "RecallMetrics \n",
      "[0.97722222 0.9088359 ]\n",
      " \n",
      "Accuracy \n",
      "0.94008632\n",
      " \n",
      "Results for .Raw, .HARFeature, and selected features flag: True\n",
      "ConfusionMatrix \n",
      "[[831.   2.   4.  32.   9.]\n",
      " [ 19. 887.   0.  12.   4.]\n",
      " [  4.   0. 855.   6.   1.]\n",
      " [150.   0.  25. 676.   1.]\n",
      " [ 96.   6.   3.  28. 288.]]\n",
      " \n",
      "PrecissionValue \n",
      "[0.75545455 0.99106145 0.96392334 0.89655172 0.95049505]\n",
      " \n",
      "RecallValue \n",
      "[0.94646925 0.96203905 0.98729792 0.79342723 0.68408551]\n",
      " \n",
      "F1ScoreValue \n",
      "[0.84024267 0.97633462 0.97547062 0.84184309 0.79558011]\n",
      " \n",
      "AccuracyValue \n",
      "0.897943640517898\n",
      " \n",
      "Inference for sit-stand \n",
      "SitStand_ConfusionMetrics \n",
      "[[1739.   61.]\n",
      " [ 256. 1883.]]\n",
      " \n",
      "PrecissionMetrics \n",
      "[0.8716792 0.9686214]\n",
      " \n",
      "RecallMetrics \n",
      "[0.96611111 0.88031791]\n",
      " \n",
      "Accuracy \n",
      "0.91952272\n",
      " \n",
      "Results for .Raw, .TransportFeatures, and selected features flag: False\n",
      "ConfusionMatrix \n",
      "[[792.   1.   6.  73.   6.]\n",
      " [ 26. 886.   0.   8.   2.]\n",
      " [  2.   0. 847.  15.   2.]\n",
      " [198.   0.  64. 585.   5.]\n",
      " [ 93.   6.   4.  53. 265.]]\n",
      " \n",
      "PrecissionValue \n",
      "[0.71287129 0.99216125 0.91965255 0.79700272 0.94642857]\n",
      " \n",
      "RecallValue \n",
      "[0.90205011 0.96095445 0.97806005 0.68661972 0.62945368]\n",
      " \n",
      "F1ScoreValue \n",
      "[0.79638009 0.97630854 0.94795747 0.73770492 0.75606277]\n",
      " \n",
      "AccuracyValue \n",
      "0.8568164508758568\n",
      " \n",
      "Inference for sit-stand \n",
      "SitStand_ConfusionMetrics \n",
      "[[1705.   95.]\n",
      " [ 299. 1840.]]\n",
      " \n",
      "PrecissionMetrics \n",
      "[0.8507984  0.95090439]\n",
      " \n",
      "RecallMetrics \n",
      "[0.94722222 0.86021505]\n",
      " \n",
      "Accuracy \n",
      "0.89997461\n",
      " \n",
      "Results for .Raw, .TransportFeatures, and selected features flag: True\n",
      "ConfusionMatrix \n",
      "[[666.   1.   6. 197.   8.]\n",
      " [ 37. 876.   0.   5.   4.]\n",
      " [  2.   0. 854.   8.   2.]\n",
      " [136.   0.  78. 632.   6.]\n",
      " [ 62.   6.   2.  80. 271.]]\n",
      " \n",
      "PrecissionValue \n",
      "[0.73754153 0.99207248 0.90851064 0.68546638 0.93127148]\n",
      " \n",
      "RecallValue \n",
      "[0.75854214 0.95010846 0.98614319 0.74178404 0.64370546]\n",
      " \n",
      "F1ScoreValue \n",
      "[0.74789444 0.97063712 0.94573643 0.71251409 0.76123596]\n",
      " \n",
      "AccuracyValue \n",
      "0.8375222137598375\n",
      " \n",
      "Inference for sit-stand \n",
      "SitStand_ConfusionMetrics \n",
      "[[1580.  220.]\n",
      " [ 206. 1933.]]\n",
      " \n",
      "PrecissionMetrics \n",
      "[0.88465845 0.897817  ]\n",
      " \n",
      "RecallMetrics \n",
      "[0.87777778 0.90369331]\n",
      " \n",
      "Accuracy \n",
      "0.89185072\n",
      " \n",
      "Results for .Raw, .HARFeature, and selected features flag: False\n",
      "ConfusionMatrix \n",
      "[[6.411e+03 5.700e+02 1.480e+02 1.345e+03 3.110e+02]\n",
      " [2.820e+02 8.695e+03 6.000e+00 1.620e+02 7.300e+01]\n",
      " [1.050e+02 3.000e+00 8.478e+03 4.800e+01 2.400e+01]\n",
      " [1.283e+03 2.680e+02 1.220e+02 6.548e+03 2.960e+02]\n",
      " [3.440e+02 6.900e+01 9.300e+01 3.210e+02 3.385e+03]]\n",
      " \n",
      "PrecissionValue \n",
      "[0.77221065 0.90661502 0.95917178 0.78573975 0.83559251]\n",
      " \n",
      "RecallValue \n",
      "[0.72973831 0.94326348 0.97921478 0.76881548 0.80366145]\n",
      " \n",
      "F1ScoreValue \n",
      "[0.74170005 0.92405406 0.9684548  0.76867826 0.81715013]\n",
      " \n",
      "AccuracyValue \n",
      "0.850901243970551\n",
      " \n",
      "Inference for sit-stand \n",
      "SitStand_ConfusionMetrics \n",
      "[[15958.  2045.]\n",
      " [ 2072. 19315.]]\n",
      " \n",
      "PrecissionMetrics \n",
      "[0.88508042 0.9042603 ]\n",
      " \n",
      "RecallMetrics \n",
      "[0.88640782 0.90311872]\n",
      " \n",
      "Accuracy \n",
      "0.89548109\n",
      " \n",
      "Results for .Raw, .HARFeature, and selected features flag: True\n",
      "ConfusionMatrix \n",
      "[[6.232e+03 6.290e+02 1.270e+02 1.417e+03 3.800e+02]\n",
      " [3.010e+02 8.658e+03 5.000e+00 1.690e+02 8.500e+01]\n",
      " [9.500e+01 3.000e+00 8.496e+03 3.600e+01 2.800e+01]\n",
      " [1.424e+03 2.420e+02 1.020e+02 6.308e+03 4.410e+02]\n",
      " [3.480e+02 6.100e+01 1.020e+02 4.610e+02 3.240e+03]]\n",
      " \n",
      "PrecissionValue \n",
      "[0.75463315 0.90437809 0.96269186 0.75994438 0.79393358]\n",
      " \n",
      "RecallValue \n",
      "[0.70936727 0.93924905 0.9812933  0.74063281 0.76924328]\n",
      " \n",
      "F1ScoreValue \n",
      "[0.7201712  0.92085993 0.97139228 0.74138269 0.77600607]\n",
      " \n",
      "AccuracyValue \n",
      "0.8361005331302362\n",
      " \n",
      "Inference for sit-stand \n",
      "SitStand_ConfusionMetrics \n",
      "[[15820.  2183.]\n",
      " [ 2173. 19214.]]\n",
      " \n",
      "PrecissionMetrics \n",
      "[0.87923081 0.89797635]\n",
      " \n",
      "RecallMetrics \n",
      "[0.87874243 0.89839622]\n",
      " \n",
      "Accuracy \n",
      "0.88941356\n",
      " \n",
      "Results for .Raw, .TransportFeatures, and selected features flag: False\n",
      "ConfusionMatrix \n",
      "[[6.116e+03 6.870e+02 2.060e+02 1.348e+03 4.280e+02]\n",
      " [3.510e+02 8.622e+03 1.100e+01 1.130e+02 1.210e+02]\n",
      " [1.110e+02 2.000e+00 8.407e+03 1.080e+02 3.000e+01]\n",
      " [1.198e+03 2.990e+02 2.560e+02 6.086e+03 6.780e+02]\n",
      " [3.850e+02 6.900e+01 1.020e+02 9.110e+02 2.745e+03]]\n",
      " \n",
      "PrecissionValue \n",
      "[0.76300127 0.89270197 0.93830331 0.70882715 0.72055284]\n",
      " \n",
      "RecallValue \n",
      "[0.69618289 0.93534414 0.97101617 0.71455151 0.6517235 ]\n",
      " \n",
      "F1ScoreValue \n",
      "[0.72226182 0.91297962 0.95307652 0.70703822 0.67477471]\n",
      " \n",
      "AccuracyValue \n",
      "0.8117796395024117\n",
      " \n",
      "Inference for sit-stand \n",
      "SitStand_ConfusionMetrics \n",
      "[[15776.  2227.]\n",
      " [ 2064. 19323.]]\n",
      " \n",
      "PrecissionMetrics \n",
      "[0.88430493 0.89665893]\n",
      " \n",
      "RecallMetrics \n",
      "[0.87629839 0.90349278]\n",
      " \n",
      "Accuracy \n",
      "0.89106372\n",
      " \n",
      "Results for .Raw, .TransportFeatures, and selected features flag: True\n",
      "ConfusionMatrix \n",
      "[[5831.  591.  233. 1691.  439.]\n",
      " [ 397. 8566.   11.  115.  129.]\n",
      " [  99.    0. 8393.  133.   33.]\n",
      " [ 656.  224.  290. 6334. 1013.]\n",
      " [ 271.   51.  105. 1035. 2750.]]\n",
      " \n",
      "PrecissionValue \n",
      "[0.8081682  0.90975895 0.93256886 0.68071759 0.67523934]\n",
      " \n",
      "RecallValue \n",
      "[0.66373999 0.92927039 0.96939954 0.74364556 0.65290439]\n",
      " \n",
      "F1ScoreValue \n",
      "[0.72637961 0.91879468 0.94899862 0.70854827 0.65282446]\n",
      " \n",
      "AccuracyValue \n",
      "0.8091901497842091\n",
      " \n",
      "Inference for sit-stand \n",
      "SitStand_ConfusionMetrics \n",
      "[[15385.  2618.]\n",
      " [ 1301. 20086.]]\n",
      " \n",
      "PrecissionMetrics \n",
      "[0.92203044 0.88468992]\n",
      " \n",
      "RecallMetrics \n",
      "[0.85457979 0.93916865]\n",
      " \n",
      "Accuracy \n",
      "0.90050774\n",
      " \n",
      "\n"
     ]
    }
   ],
   "source": [
    "'''Read the value for one of the machine learning algorithm'''\n",
    "file = os.path.join(ResultPathDir,f'{ClassifierName}.txt')\n",
    "f = open(file, \"r\")\n",
    "print(f.read())"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
